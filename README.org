* GENRIC-CL
#+OPTIONS: toc:nil

GENERIC-CL provides a generic function wrapper over various functions
in the Common Lisp standard, such as equality predicates and sequence
operations. The goal of the wrapper is to provide a standard interface
to common operations, such as testing for the equality of two objects,
which is extensible to user-defined types.

#+TOC: headlines 3

** Usage

The generic function interface is contained in the ~GENERIC-CL~
package. This package should be used rather than ~COMMON-LISP~, as it
shadows the symbols, in the ~COMMON-LISP~ package, which name a
function for which there is a generic function wrapper. The
~GENERIC-CL~ additionally reexports the remaining non-shadowed symbols
in ~COMMON-LISP~.

** Generic Interfaces

The generic function interface consists of the following functions
divided into the following categories:

*** Equality

The equality interface provides functions for testing objects for
equality.

**** EQUALP

Generic Function: ~EQUALP A B~

Returns true if object ~A~ is equal to object ~B~.

Has methods specialized on the following types:

   - ~NUMBER NUMBER~

     Returns true if ~A~ and ~B~ represent the same numeric value,
     as per ~CL:=~.

   - ~CHARACTER CHARACTER~

     Returns true if ~A~ and ~B~ represent the same character, as per
     ~CL:CHAR=~.

   - ~CONS CONS~

     Returns true if the ~CAR~ of ~A~ is equal (by ~EQUALP~) to the
     ~CAR~ of ~B~ and if the ~CDR~ of ~A~ is equal (by ~EQUALP~) to
     the ~CDR~ of ~B~.

   - ~VECTOR VECTOR~

     Returns true if ~A~ and ~B~ are vectors of the same length and
     each element of ~A~ is equal (by ~EQUALP~) to the corresponding
     element of ~B~.

   - ~ARRAY ARRAY~

     Multi-dimensional arrays.

     Returns true if ~A~ and ~B~ have the same dimensions and each
     element of ~A~ is equal (by ~EQUALP~) to the corresponding
     element of ~B~.

   - ~STRING STRING~

     Returns true if both strings are equal (by ~CL:STRING=~).

   - ~PATHNAME PATHNAME~

     Returns true if both ~PATHNAME~ objects are functionally
     equivalent, as per the ~PATHNAME-EQUAL~ function from the
     ~CL-FAD~ library.

   - ~T T~

     Default method.

     Returns true if ~A~ and ~B~ are the same object,
     as per ~CL:EQ~.


**** =

Function: ~= X &REST XS~

Returns true if all objects in ~XS~ are equal (by ~EQUALP~) to ~X~.

**** /=

Function: ~= X &REST XS~

Returns true if at least one object in ~XS~ is not equal (by ~EQUALP~)
to ~X~.

*** Comparison

The comparison interface provides functions for comparing objects in
terms of greater than, less than, greater than or equal to and less
than or equal to relations.

**** LESSP

Generic Function: ~LESSP A B~

Returns true if object ~A~ is less than object ~B~.

It is sufficient to just implement this function, for user-defined
types, as the rest of the comparison functions have default (~T T~)
methods which are implemented in terms of ~LESSP~.

Has the following methods:

   - ~NUMBER NUMBER~

     Returns true if the numeric value of ~A~ is less than the numeric
     value of ~B~, by ~CL:<~.

   - ~CHARACTER CHARACTER~

     Returns true if the character code of ~A~ is less than the
     character code of ~B~, by ~CL:CHAR<~.

   - ~STRING STRING~

     Returns true if the string ~A~ is lexicographically less than
     ~B~, by ~CL:STRING<~.


**** LESS-EQUAL-P

Generic Function: ~LESS-EQUAL-P A B~

Returns true if object ~A~ is less than or equal to object ~B~.

Has the following methods:

   - ~NUMBER NUMBER~

     Returns true if the numeric value of ~A~ is less than or equal to
     the numeric value of ~B~, by ~CL:<=~.

   - ~CHARACTER CHARACTER~

     Returns true if the character code of ~A~ is less than or equal
     to the character code of ~B~, by ~CL:CHAR<=~.

   - ~STRING STRING~

     Returns true if the string ~A~ is lexicographically less than or
     equal to ~B~, by ~CL:STRING<=~.

   - ~T T~

     Returns true if either ~A~ is less than ~B~ (by ~LESSP~) or ~A~
     is equal to ~B~ (by ~EQUALP).

     #+BEGIN_SRC lisp
     (or (lessp a b) (equalp a b))
     #+END_SRC


**** GREATERP

Generic Function: ~GREATERP A B~

Returns true if object ~A~ is greater than object ~B~.

Has the following methods:

   - ~NUMBER NUMBER~

     Returns true if the numeric value of ~A~ is greater than the
     numeric value of ~B~, by ~CL:>~.

   - ~CHARACTER CHARACTER~

     Returns true if the character code of ~A~ is greater than the
     character code of ~B~, by ~CL:CHAR>~.

   - ~STRING STRING~

     Returns true if the string ~A~ is lexicographically greater than
     ~B~, by ~CL:STRING>~.

   - ~T T~

     Returns true if ~A~ is not less than or equal to ~B~, by ~LESS-EQUAL-P~.

     #+BEGIN_SRC lisp
     (not (less-equal-p a b))
     #+END_SRC


**** GREATER-EQUALP

Generic Function: ~GREATER-EQUAL-P A B~

Returns true if object ~A~ is greater than or equal to object ~B~.

Has the following methods:

   - ~NUMBER NUMBER~

     Returns true if the numeric value of ~A~ is greater than or equal
     to the numeric value of ~B~, by ~CL:>=~.

   - ~CHARACTER CHARACTER~

     Returns true if the character code of ~A~ is greater than or
     equal to the character code of ~B~, by ~CL:CHAR>=~.

   - ~STRING STRING~

     Returns true if the string ~A~ is lexicographically greater than
     or equal to ~B~, by ~CL:STRING>=~.

   - ~T T~

     Returns true if ~A~ is not less than ~B~, by ~LESSP~.

     #+BEGIN_SRC lisp
     (not (lessp a b))
     #+END_SRC


**** COMPARE

Generic Function: ~COMPARE A B~

Returns:

   - ~:LESS~ :: if ~A~ is less than ~B~.
   - ~:EQUAL~ :: if ~A~ is equal to ~B~.
   - ~:GREATER~ :: if ~A~ is greater than ~B~.

The default ~T T~ method returns:

   - ~:LESS~ :: if ~(LESSP A B)~ is true.
   - ~:EQUAL~ :: if ~(EQUALP A B)~ is true.
   - ~:GREATER~ :: otherwise.

**** >

Function: ~< X &REST XS~

Returns true if each argument is less than (by ~LESSP~) than the
following argument.

**** <=

Function: ~<= X &REST XS~

Returns true if each argument is less than or equal to (by ~LESS-EQUAL-P~)
than the following argument.

**** <

Function: ~> X &REST XS~

Returns true if each argument is greater than (by ~GREATERP~) than the
following argument.

**** >=

Function: ~>= X &REST XS~

Returns true if each argument is greater than or equal to (by
~GREATER-EQUAL-P~) than the following argument.

**** MIN

Function: ~MIN X &REST XS~

Returns the argument which is less than or equal to all other
arguments, the actual comparisons are performed using ~LESSP~. Any one
of the arguments which satisfies this condition may be returned.

**** MAX

Function: ~MAX X &REST XS~

Returns the argument which is greater than or equal to all other
arguments, the actual comparisons are performed using ~GREATERP~. Any
one of the arguments which satisfies this condition may be returned.

*** Arithmetic

The arithmetic interface provides generic functions for arithmetic
operations.

**** ADD

Generic Function: ~ADD A B~

Returns the sum of ~A~ and ~B~.

Methods:

   - ~NUMBER NUMBER~

     Returns ~(CL:+ A B)~.

**** SUBTRACT

Generic Function: ~SUBTRACT A B~

Returns the sum of ~A~ and ~B~.

Methods:

   - ~NUMBER NUMBER~

     Returns ~(CL:- A B)~.

**** MULTIPLY

Generic Function: ~MULTIPLY A B~

Returns the sum of ~A~ and ~B~.

Methods:

   - ~NUMBER NUMBER~

     Returns ~(CL:* A B)~.

**** DIVIDE

Generic Function: ~DIVIDE A B~

Returns the sum of ~A~ and ~B~. If ~A~ is the constant ~1~, the result
should be the reciprocal of ~B~.

Methods:

   - ~NUMBER NUMBER~

     Returns ~(CL:/ A B)~.

**** NEGATE

Generic Function: ~NEGATE A~

Returns the negation of ~A~.

Methods:

   - ~NUMBER~

     Returns ~(CL:- A)~.

**** +

Function: ~+ X &REST XS~

Returns the sum of all the arguments, computed by reducing over the
argument list with the ~ADD~ function.

If no arguments are provided, ~0~ is returned. If a single argument is
provided it is returned.

**** -

Function: ~- X &REST XS~

Returns the difference of all the arguments, computed by reducing over
the argument list with the ~SUBTRACT~ function.

If only a single argument is provided the negation of that argument is
returned, by the ~NEGATE~ function.

**** *

Function: ~* X &REST XS~

Returns the product of all the arguments, computed by reducing over
the argument list with the ~MULTIPLY~ function.

If no arguments are provided, ~1~ is returned. If a single argument is
provided it is returned.

**** /

Function: ~/ X &REST XS~

Returns the quotient of all the arguments, computed by reducing over
the argument list with the ~DIVIDE~ function.

If only a single argument is provided it, the reciprocal of that
argument, ~(DIVIDE 1 X)~, is returned.

**** 1+

Generic Function: ~1+ A~

Returns ~A + 1~.

Methods:

   - ~NUMBER~

     Returns ~(CL:1+ A)~.

   - ~T~

     Returns ~(ADD A 1)~.

**** 1-

Generic Function: ~1- A~

Returns ~A - 1~.

Methods:

   - ~NUMBER~

     Returns ~(CL:1- A)~.

   - ~T~

     Returns ~(SUBTRACT A 1)~.

**** INCF

Macro: ~INCF PLACE &OPTIONAL (DELTA 1)~

Increments the value of ~PLACE~ by ~DELTA~, which defaults to ~1~,
using the ~ADD~ function.

Effectively:

#+BEGIN_SRC lisp
(setf place (add place delta))
#+END_SRC

**** DECF

Macro: ~DECF PLACE &OPTIONAL (DELTA 1)~

Decrements the value of ~PLACE~ by ~DELTA~, which defaults to ~1~,
using the ~SUBTRACT~ function.

Effectively:

#+BEGIN_SRC lisp
(setf place (subtract place delta))
#+END_SRC

**** MINUSP

Generic Function: ~MINUSP A~

Returns true if ~A~ is less than zero.

Methods:

   - ~NUMBER~

     Returns ~(CL:MINUSP A)~.

   - ~T~

     Returns true if ~A~ compares less than ~0~, by ~LESSP~.

     #+BEGIN_SRC lisp
     (lessp a 0)
     #+END_SRC

**** PLUSP

Generic Function: ~PLUSP A~

Returns true if ~A~ is greater than zero.

Methods:

   - ~NUMBER~

     Returns ~(CL:PLUSP A)~.

   - ~T~

     Returns true if ~A~ compares greater than ~0~, by ~GREATERP~.

     #+BEGIN_SRC lisp
     (greaterp a 0)
     #+END_SRC

**** ZEROP

Generic Function: ~ZEROP A~

Returns true if ~A~ is equal to zero.

Methods:

   - ~NUMBER~

     Returns ~(CL:ZEROP A)~.

   - ~T~

     Returns true if ~A~ is equal to ~0~, by ~EQUALP~.

     #+BEGIN_SRC lisp
     (equalp a 0)
     #+END_SRC

**** SIGNUM

Generic Function: ~SIGNUM A~

Returns ~-1~, ~0~ or ~1~ depending on whether ~A~ is negative, ~A~ is
equal to zero or ~A~ is positive.

Methods:

   - ~SIGNUM~

     Returns ~(CL:SIGNUM A)~.

   - ~T~

     Returns ~-1~ if ~(MINUSP A)~ is true, ~0~ if ~(ZEROP A)~ is true,
     ~1~ otherwise.

**** ABS

Generic Function: ~ABS A~

Returns the absolute value of ~A~.

Methods:

   - ~NUMBER~

     Returns ~(CL:ABS A)~.

   - ~T~

     If ~(MINUSP A)~ is true, returns ~(NEGATE A)~ otherwise returns
     ~A~.

     #+BEGIN_SRC lisp
     (if (minusp a)
         (negate a)
         a)
     #+END_SRC

**** EVENP

Generic Function: ~EVENP A~

Returns true if ~A~ is even.

Methods:

   - ~NUMBER~

     Returns ~(CL:EVENP A)~

   - ~T~

     Returns ~(ZEROP (MOD A 2))~

**** ODDP

Generic Function: ~ODDP A~

Returns true if ~A~ is odd.

Methods:

   - ~NUMBER~

     Returns ~(CL:ODDP A)~

   - ~T~

     Returns ~(NOT (EVENP A))~


**** FLOOR

Generic Function: ~FLOOR N D~

Returns ~N~, or ~N/D~ if ~D~ is provided, rounded towards negative
infinity, as the first value, and the remainder of the division if
any, as the second return value.

Methods:

   - ~NUMBER~

     Returns ~(CL:FLOOR N D)~ if ~D~ is provided otherwise returns
     ~(CL:FLOOR N)~.

**** CEILING

Generic Function: ~CEILING N D~

Returns ~N~, or ~N/D~ if ~D~ is provided, rounded towards positive
infinity, as the first value, and the remainder of the division if
any, as the second return value.

Methods:

   - ~NUMBER~

     Returns ~(CL:CEILING N D)~ if ~D~ is provided otherwise returns
     ~(CL:CEILING N)~.

**** TRUNCATE

Generic Function: ~TRUNCATE N D~

Returns ~N~, or ~N/D~ if ~D~ is provided, rounded towards zero, as the
first value, and the remainder of the division if any, as the second
return value.

Methods:

   - ~NUMBER~

     Returns ~(CL:TRUNCATE N D)~ if ~D~ is provided otherwise returns
     ~(CL:TRUNCATE N)~.

**** ROUND

Generic Function: ~ROUND N D~

Returns ~N~, or ~N/D~ if ~D~ is provided, rounded towards the nearest
integer. If ~N~, or ~N/D~, lies exactly halfway between two integers,
it is rounded to the nearest even integer. The remainder of the
division if any, is returned as the second return value.

Methods:

   - ~NUMBER~

     Returns ~(CL:ROUND N D)~ if ~D~ is provided otherwise returns
     ~(CL:ROUND N)~.

**** MOD

Generic Function: ~MOD N D~

Returns the remainder of the ~FLOOR~ operation on ~N~ and ~D~.

Methods:

   - ~NUMBER~

     Returns ~(CL:MOD N D)~.

   - ~T~

     Returns the second return value of ~(FLOOR N D)~.

**** REM

Generic Function: ~REM N D~

Returns the remainder of the ~TRUNCATE~ operation on ~N~ and ~D~.

Methods:

   - ~NUMBER~

     Returns ~(CL:REM N D)~.

   - ~T~

     Returns the second return value of ~(TRUNCATE N D)~.

*** Objects

The object interface provides miscellaneous functions for manipulating
objects.

**** COPY

Generic Function: ~COPY OBJECT &KEY &ALLOW-OTHER-KEYS~

Returns a copy of ~OBJECT~. If ~OBJECT~ is mutable, by some other
functions, then the returned object should be distinct (not ~EQ~) from
~OBJECT~, otherwise the return value may be identical (~EQ~) to
~OBJECT~.

This function may accept additional keyword arguments which specify
certain options as to how the object should be copied. Methods
specialized on sequences accept a ~:DEEP~ keyword parameter, which if
provided and is true a deep copy is returned otherwise a shallow copy
is returned. If this applicable to a user-defined type, the ~COPY~
method for that type should also accept the ~DEEP~ keyword parameter.

Methods:

   - ~CONS~

     Returns a new list which contains all the elements in
     ~OBJECT~. If ~:DEEP~ is provided and is true, the list returned
     contains a copy of elements, copied using ~(COPY ELEM :DEEP T)~.

   - ~VECTOR~

     Returns a new vector which contains all the elements in
     ~OBJECT~. If ~:DEEP~ is provided and is true, the vector returned
     contains a copy of elements, copied using ~(COPY ELEM :DEEP T)~.

   - ~ARRAY~

     Multi-Dimensional Arrays.

     Returns a new array, of the same dimensions as ~OBJECT~, which
     contains all the elements in ~OBJECT~. If ~:DEEP~ is provided and
     is true, the array returned contains a copy of elements, copied
     using ~(COPY ELEM :DEEP T)~.

   - ~T~

     Simply returns ~OBJECT~.

     This method is provided to allow sequences containing arbitrary
     objects to be copied safely, without signaling a condition, and
     to avoid having to write simple pass-through methods for each
     user-defined type.

     However this means that if the object, for which there is no
     specialized copy method, can be mutated, the constraints of the
     ~COPY~ function are violated.


**** DEFSTRUCT

Macro: ~DEFSTRUCT OPTIONS &REST SLOTS~

This is the same as ~CL:DEFSTRUCT~ however a ~COPY~ method for the
structure type is automatically generated, which simply calls the
structure's copier function. If the ~(:COPIER NIL)~ option is
provided, the ~COPY~ method is not generated.

**** COERCE

Generic Function: ~COERCE OBJECT TYPE~

Coerces ~OBJECT~ to the type ~TYPE~.

The default (~T T~) method simply calls ~CL:COERCE~.

*** Iterator

The iterator interface is a generic interface for iterating over the
elements of sequences and containers.

The iterator interface is implemented for lists, vectors,
multi-dimensional arrays and ~HASH-MAPS~.

**** Base Iterator Type

Structure: ~ITERATOR~

This structure serves as the base iterator type and is used as by
certain methods of generic functions to specialize on iterators.

All iterators should inherit from (include) ~ITERATOR~, in order for
methods which specialize on iterators to be invoked.

*Note:* A ~COPY~ method should be implemented for user-defined
iterators.

**** Iterator Creation

[[#iterator-func][ITERATOR]] is the high-level function for creating iterators, whereas
[[#make-iterator][MAKE-ITERATOR]] AND [[#make-reverse-iterator][MAKE-REVERSE-ITERATOR]] are the generic functions to
implement for creating iterators for user-defined sequence types.

***** MAKE-ITERATOR
      :PROPERTIES:
      :CUSTOM_ID: make-iterator
      :END:

Generic Function: ~MAKE-ITERATOR SEQUENCE START END~

Returns an iterator for the sub-sequence of ~SEQUENCE~, identified by
the range ~[START, END)~.

~START~ is the index of the first element to iterate over. ~0~
indicates the first element of the sequence.

~END~ is the index of the element at which to terminate the iteration,
i.e.  1 + the index of the last element to be iterated over. ~NIL~
indicates the end of the sequence.

***** MAKE-REVERSE-ITERATOR
      :PROPERTIES:
      :CUSTOM_ID: make-reverse-iterator
      :END:

Generic Function: ~MAKE-REVERSE-ITERATOR SEQUENCE START END~

Returns an iterator for the sub-sequence of ~SEQUENCE~, identified by
the range ~[START, END)~, in which the elements are iterated over in
reverse order.

Even though the elements are iterated over in reverse order, ~START~
and ~END~ are still relative to the start of the sequence, as in
~MAKE-ITERATOR~.

~START~ is the index of the last element to visit.

~END~ is the index of the element following the first element to be
iterated over.

***** ITERATOR
      :PROPERTIES:
      :CUSTOM_ID: iterator-func
      :END:

Function: ~ITERATOR SEQUENCE &KEY (START 0) END FROM-END~

Returns an iterator for the sub-sequence of ~SEQUENCE~ identified by
the range ~[START, END)~.

~START~ (defaults to ~0~ - the start of the sequence) and ~END~
(defaults to ~NIL~ - the end of the sequence) are the start and end
indices of the sub-sequence to iterated over (see [[#make-iterator][MAKE-ITERATOR]] and
[[#make-reverse-iterator][MAKE-REVERSE-ITERATOR]] for more information).

If ~FROM-END~ is true a reverse iterator is created (by
~MAKE-REVERSE-ITERATOR~) otherwise a normal iterator is created (by
~MAKE-ITERATOR~).

**** Mandatory Functions

These functions have to be implemented for all user-defined iterators.

***** AT

Generic Function: ~AT ITERATOR~

Returns the value of the element at the current position of the
iterator ~ITERATOR~.

The effects of calling this method, after the iterator has reached the
end of the subsequence are unspecified.

***** ENDP

Generic Function: ~ENDP ITERATOR~

Returns true if the iterator is at the end of the subsequence, false
otherwise.

The end of the subsequence is defined as the position past the last
element of the subsequence, that is the position of the iterating
after advancing it (by ~ADVANCE~) from the position of the last
element.

If the subsequence is empty ~ENDP~ should immediately return true.

*Note:* The default ~T~ method calls ~CL:ENDP~ since this function
shadows the ~CL:ENDP~ function.

***** ADVANCE

Generic Function: ~ADVANCE ITERATOR~

Advances the iterator to the next element in the subsequence. After
this method is called, subsequent calls to ~AT~ should return the next
element in the sequence or if the last element has already been
iterated over, ~ENDP~ should return true.

**** Optional Functions

Implementing the following functions for user-defined iterators is
optional either because, a default method is provided which is
implemented using the mandatory functions, or the function is only
used by a selected few sequence operations.

***** START

Generic Function: ~START ITERATOR~

Returns the element at the current position of the iterator, if the
iterator is not at the end of the sequence, otherwise returns ~NIL~.

The default method first checks whether the end of the iterator has
been reached, using ~ENDP~, and if not returns the current element
using ~AT~.

The default method is equivalent to the following:

#+BEGIN_SRC lisp
(unless (endp iterator)
  (at iterator))
#+END_SRC

***** (SETF AT)
      :PROPERTIES:
      :CUSTOM_ID: setf-at
      :END:

Generic Function: ~(SETF AT) VALUE ITERATOR~

Sets the value of the element at the position, in the sequence,
specified by the iterator.

The effects of calling this function when, the iterator is past the
end of the subsequence are unspecified.

Implementing this function is only mandatory if destructive sequence
operations will be used.

***** ADVANCE-N

Generic Function: ~ADVANCE-N ITERATOR N~

Advances the iterator by ~N~ elements. This position should be
equivalent to the positioned obtained by calling ~ADVANCE~ ~N~ times.

The default method simply calls ~ADVANCE~, on ~ITERATOR~, ~N~ times.

**** Macros

***** DOITERS
      :PROPERTIES:
      :CUSTOM_ID: doiters
      :END:

Macro: ~DOITERS (&REST ITERS) &BODY BODY~

Iterates over one or more sequences with the sequence iterators bound
to variables.

Each element of ITERS is a list of the form ~(IT-VAR SEQUENCE
. ARGS)~, where ~IT-VAR~ is the variable to which the iterator is
bound, ~SEQUENCE~ is the sequence which will be iterated over and
~ARGS~ are the remaining arguments passed to the [[#iterator-func][ITERATOR]] function.

The bindings to the ~IT-VARS~'s are visible to the forms in ~BODY~,
which are executed once for each element in the sequence. After each
iteration the sequence iterators are ~ADVANCE~'d. The loop terminates
when the end of a sequence is reached.

***** DOITER

Macro: ~DOITER (ITER &REST ARGS) &BODY BODY~

The is the same as [[#doiters][DOITERS]] except only a single sequence is iterated
over.

***** DOSEQ

Macro: ~DOSEQ (ELEMENT SEQUENCE &REST ARGS) &BODY BODY~

Iterates over the elements of ~SEQUENCE~. ~ARGS~ are the remaining
arguments passed to the [[#iterator-func][ITERATOR]] function.

The forms in ~BODY~ are executed once for each element, with the value
of the element bound to ~ELEMENT~.

*** Collector

The collector interface is a generic interface for accumulating items
in a sequence/container.

The collector interface is implemented for lists, vectors and
~HASH-MAPS~.

**** MAKE-COLLECTOR

Generic Function: ~MAKE-COLLECTOR SEQUENCE &KEY FRONT~

Returns a collector for accumulating items onto the back of the
sequence ~SEQUENCE~. If ~:FRONT~ is provided and is true, the items
are accumulated to the front of the sequence rather than back.

The collector may destructively modify ~SEQUENCE~ however it is not
mandatory and may accumulate items into a copy of ~SEQUENCE~ instead.

**** ACCUMULATE

Generic Function: ~ACCUMULATE COLLECTOR ITEM~

Accumulates ~ITEM~ into the sequence associated with the collector
~COLLECTOR~.

**** COLLECTOR-SEQUENCE

Generic Function: ~COLLECTOR-SEQUENCE COLLECTOR~

Returns the underlying sequence associated with the collector
~COLLECTOR~. The sequence should contain all items accumulated up to
the call to this function.

No items should be accumulated, by ~ACCUMULATE~ or ~EXTEND~, after
this function is called.

The sequence returned might not be the same object passed to
~MAKE-COLLECTOR~.

**** EXTEND

Generic Function: ~EXTEND COLLECTOR SEQUENCE~

Accumulates all elements of the sequence ~SEQUENCE~ into the sequence
associated with the collector ~COLLECTOR~.

If ~SEQUENCE~ is an iterator all elements up-to the end of the
iterator (till ~ENDP~ returns true) should be accumulated.

Implementing this method is optional as default methods are provided
for iterators and sequences, which simply accumulate each element one
by one using ~ACCUMULATE~.

Methods:

   - ~T ITERATOR~

     Accumulates all elements returned by the iterator ~SEQUENCE~
     (till ~(ENDP SEQUENCE)~ returns true), into the sequence
     associated with the collector. The elements are accumulated one
     by one using ~ACCUMULATE~.

     The iterator is copied thus the position of the iterator passed
     as an argument is not modified.

   - ~T T~

     Accumulates all elements of ~SEQUENCE~, into the sequence
     associated with the collector. The elements are accumulated one
     by one using ~ACCUMULATE~.

     The sequence iteration is done using the iterator interface.

*** Sequences

**** Creation

The following functions are for creating a sequence into which items
will be accumulated using the collector interface.

***** CLEARED
      :PROPERTIES:
      :CUSTOM_ID: cleared
      :END:

Generic Function: ~CLEARED SEQUENCE &KEY &ALLOW-OTHER-KEYS~

Returns a new empty sequence, of the same type and with the same
properties as ~SEQUENCE~, suitable for accumulating items into it
using the collector interface.

Individual methods may accept keyword parameters which specify certain
options of the sequence which is to be created.

Methods:

   - ~LIST~

     Returns ~NIL~.

   - ~VECTOR~

     Returns an adjustable vector of the same length as ~SEQUENCE~,
     with the fill-pointer set to ~0~.

     If the ~:KEEP-ELEMENT-TYPE~ argument is provided and is true, the
     element type of the new vector is the same as the element type of
     ~SEQUENCE~.

***** MAKE-SEQUENCE-OF-TYPE

Generic Function: ~MAKE-SEQUENCE-OF-TYPE TYPE ARGS~

Returns a new empty sequence of type ~TYPE~. ~ARGS~ are the type
arguments, if any.

The default method creates a built-in sequence of the same type as
that returned by:

#+BEGIN_SRC lisp
(make-sequence (cons type args) 0)
#+END_SRC

***** SEQUENCE-OF-TYPE

Function: ~SEQUENCE-OF-TYPE TYPE~

Creates a new sequence of type ~TYPE~, using
~MAKE-SEQUENCE-OF-TYPE~.

If ~TYPE~ is a list the ~CAR~ of the list is passed as the first
argument, to ~MAKE-SEQUENCE-OF-TYPE~, and the ~CDR~ is passed as the
second argument. Otherwise, if ~TYPE~ is not a list, it is passed as
the first argument and ~NIL~ is passed as the second argument.

**** Element Access

***** ELT

Generic Function: ~ELT SEQUENCE INDEX~

Returns the element at position ~INDEX~ in the sequence ~SEQUENCE~.

Methods:

   - ~SEQUENCE T~

     Returns ~(CL:ELT SEQUENCE INDEX)~.

***** (SETF ELT)

Generic Function: ~(SETF ELT) VALUE SEQUENCE INDEX~

Sets the value of the element at position ~INDEX~ in the sequence
~SEQUENCE~.

Methods:

   - ~T SEQUENCE T~

     Returns ~(SETF (CL:ELT SEQUENCE INDEX) VALUE)~.

***** FIRST

Generic Function: ~FIRST SEQUENCE~

Returns the first element in the sequence ~SEQUENCE~.

Implemented for lists, vectors and multi-dimensional arrays. For
multi-dimensional arrays, the first element is obtained by
~ROW-MAJOR-AREF~.

The default method returns the first element of a generic sequence by
creating an iterator for the sequence and returning the first element
returned by the iterator.

***** LAST

Generic Function: ~LAST SEQUENCE~

Returns the last element of the sequence ~SEQUENCE~.

Implemented for lists, vectors and multi-dimensional arrays. For
multi-dimensional arrays, the last element is obtained by:

#+BEGIN_SRC lisp
(row-major-aref sequence (1- (array-total-size array)))
#+END_SRC

The default method returns the last element of a generic sequence by
creating a reverse iterator for the sequence and returning the first
element element returned by the iterator.

*Note:* The behaviour of this function differs from ~CL:LAST~ when
called on lists, it returns the last element rather than the last
~CONS~ cell.


**** Length

***** Length

Generic Function: ~LENGTH SEQUENCE~

Returns the number of elements in the sequence ~SEQUENCE~. If
~SEQUENCE~ is an iterator, returns the number of remaining elements to
be iterated over.

This function is implemented for all Common Lisp sequences, returning
the length of the sequence (by ~CL:LENGTH~), multi-dimensional arrays,
returning the total number of elements in the array (by
~ARRAY-TOTAL-SIZE~), and hash maps/hash tables, returning the total
number of elements in the map/table.

The following default methods are implemented:

   - ~ITERATOR~

     Returns the number of elements between the iterator's current
     position (inclusive) and the end of the iterator's subsequence.

     This is implemented by advancing the iterator (by ~ADVANCE~) till
     ~ENDP~ returns true, thus is a linear ~O(n)~, in time, operation.

     More efficient specialized methods are provided for iterators to
     sequences for which the size is known.

   - ~T~

     Returns the length of the generic sequence by creating an
     iterator to the sequence and calling the ~ITERATOR~ specialized
     method. Thus this is a linear ~O(n)~, in time, operation unless a
     more efficient method, which is specialized on the sequence's
     iterator type, is implemented.


**** Subsequences

***** SUBSEQ
      :PROPERTIES:
      :CUSTOM_ID: subseq
      :END:

Generic Function: ~SUBSEQ SEQUENCE START &OPTIONAL END~

Returns a new sequence that contains the elements of ~SEQUENCE~ at the
positions in the range ~[START, END)~. If ~SEQUENCE~ is an iterator,
an iterator for the sub-sequence relative to the current position of
the iterator is returned.

~START~ is the index of the first element of the subsequence, with ~0~
indicating the start of the sequence. if ~SEQUENCE~ is an iterator,
~START~ is the number of times the iterator should be ~ADVANCE~'d to
reach the first element of the subsequence.

~END~ is the index of the element following the last element of the
subsequence. ~NIL~ (the default) indicates the end of the sequence. If
~SEQUENCE~ is an iterator, ~END~ is the number of times the iterator
should be ~ADVANCE~'d till the end position is reached.

Methods:

   - ~SEQUENCE T~

     Returns the subsequence using ~CL:SUBSEQ~.

   - ~ITERATOR T~

     Returns a subsequence iterator which wraps a copy of the original
     iterator.

   - ~T T~

     Returns the subsequence of the generic sequence. This requires
     that the ~CLEARED~ method, the iterator interface and collector
     interface are implemented for the generic sequence type.

***** (SETF SUBSEQ)

Generic Function: ~(SETF SUBSEQ) NEW-SEQUENCE SEQUENCE START &OPTIONAL END~

Replaces the elements of ~SEQUENCE~ at the positions in the range
~[START, END)~, with the elements of ~NEW-SEQUENCE~. The shorter
length of ~NEW-SEQUENCE~ and the number of elements between ~START~
and ~END~ determines how many elements of ~SEQUENCE~ are actually
modified.

See [[#subseq][SUBSEQ]] for more details of how the ~START~ and ~END~ arguments are
interpreted.

Methods:

   - ~SEQEUNCE SEQUENCE T~

     Sets the elements of the subsequence using ~(SETF CL:SUBSEQ)~.

   - ~T T T~

     Sets the elements of the generic sequence using the iterator
     interface, which should be implemented for both the types of
     ~SEQUENCE~ and ~NEW-SEQUENCE~. This method requires that the
     ~(SETF AT)~ method is implemented for the iterator type of
     ~SEQUENCE~.

**** Sequence Operations

Generic function wrappers, which are identical in behavior to their
counterparts in the ~COMMON-LISP~ package, are provided for the
following sequence operations:

   - ~FILL~
   - ~REPLACE~
   - ~REDUCE~
   - ~COUNT~
   - ~COUNT-IF~
   - ~COUNT-IF-NOT~
   - ~FIND~
   - ~FIND-IF~
   - ~FIND-IF-NOT~
   - ~POSITION~
   - ~POSITION-IF~
   - ~POSITION-IF-NOT~
   - ~SEARCH~
   - ~MISMATCH~
   - ~REVERSE~
   - ~NREVERSE~
   - ~SUBSTITUTE~
   - ~NSUBSTITUTE~
   - ~SUBSTITUTE-IF~
   - ~NSUBSTITUTE-IF~
   - ~SUBSTITUTE-IF-NOT~
   - ~NSUBSTITUTE-IF-NOT~
   - ~REMOVE~
   - ~DELETE~
   - ~REMOVE-IF~
   - ~DELETE-IF~
   - ~REMOVE-IF-NOT~
   - ~DELETE-IF-NOT~
   - ~REMOVE-DUPLICATES~
   - ~DELETE-DUPLICATES~

Two methods are implemented for all functions:

   - ~CL:SEQUENCE~

     Simply calls the corresponding function in the ~COMMON-LISP~
     package.

   - ~T~

     Implements the sequence operation for generic sequences using the
     iterator interface.

     The non-destructive functions only require that the mandatory
     iterator functions, the collector interface and [[#cleared][CLEARED]] method
     are implemented for the sequence's type.

     The destructive versions may additionally require that the
     optional [[#setf-at][(SETF AT)]] method is implemented as well.

The default value of the ~:TEST~ keyword arguments is
~GENERIC-CL:EQUALP~, this should be the default value when
implementing methods of these functions. The ~:TEST-NOT~ keyword
arguments have been removed.

The following functions are identical in behavior to their ~CL~
counterparts, however are re-implemented using the iterator
interface. Unlike the functions in the previous list, these are not
generic functions since they take an arbitrary number of sequences as
arguments.

   - ~EVERY~
   - ~SOME~
   - ~NOTEVERY~
   - ~NOTANY~

The following functions either have no ~CL~ counterparts or differ
slightly in behavior from their ~CL~ counterparts.

***** MERGE

Generic Function: ~MERGE SEQUENCE1 SEQUENCE2 PREDICATE &KEY~

Returns a new sequence, of the same type as ~SEQUENCE1~, containing
the elements of ~SEQUENCE1~ and ~SEQUENCE2~. The elements are ordered
according to the function ~PREDICATE~.

Unlike ~CL:MERGE~ this function is non-destructive.

***** NMERGE

Generic Function: ~MERGE SEQUENCE1 SEQUENCE2 PREDICATE &KEY~

Same as ~MERGE~ however is permitted to destructively modify either
~SEQUENCE1~ or ~SEQUENCE2~.

***** SORT

Generic Function: ~SORT SEQUENCE &KEY TEST KEY~

Returns a new sequence of the same type as ~SEQUENCE~, with the same
elements sorted according to the order determined by the function
~TEST~. ~TEST~ is ~GENERIC-CL:LESSP~ by default.

Unlike ~CL:SORT~ this function is non-destructive.

The default ~T~ method requires that ~SUBSEQ~ and ~LENGTH~ methods are
implemented for ~SEQUENCE~'s iterator type.

***** STABLE-SORT

Generic Function: ~STABLE-SORT SEQUENCE &KEY TEST KEY~

Same as ~SORT~ however the sort operation is guaranteed to be
stable. ~TEST~. ~TEST~ is ~GENERIC-CL:LESSP~ by default.

Unlike ~CL:STABLE-SORT~ this function is non-destructive.

The default ~T~ method requires that ~SUBSEQ~ and ~LENGTH~ methods are
implemented for ~SEQUENCE~'s iterator type.

***** NSORT

Generic Function: ~NSORT SEQUENCE &KEY TEST KEY~

Same as ~SORT~ however is permitted to destructively modify
~SEQUENCE~.

***** STABLE-NSORT

Generic Function: ~STABLE-NSORT SEQUENCE &KEY TEST KEY~

Same as ~STABLE-SORT~ however is permitted to destructively modify
~SEQUENCE~.

***** CONCATENATE

Function: ~CONCATENATE SEQUENCE &REST SEQUENCES~

Returns a new sequence, of the same type as ~SEQUENCE~, containing all
the elements of ~SEQUENCE~ and of each sequence in ~SEQUENCES~, in the
order they are supplied.

Unlike ~CL:CONCATENATE~ does not take a result type argument.

***** NCONCATENATE

Function: ~NCONCATENATE RESUL &REST SEQUENCES~

Destructively concatenates each sequence in ~SEQUENCES~ to the
sequence ~RESULT~.

***** MAP

Function: ~MAP FUNCTION SEQUENCE &REST SEQUENCES~

Creates a new sequence, of the same type as ~SEQUENCE~ (by ~CLEARED~),
containing the result of applying ~FUNCTION~ to each element of
SEQUENCE and each element of each ~SEQUENCE~ in ~SEQUENCES~.

This is equivalent (in behavior) to the ~CL:MAP~ function except the
resulting sequence is always of the same type as the first sequence
passed as an argument, rather than being determined by a type
argument.

***** NMAP

Function: ~NMAP RESULT FUNCTION &REST SEQUENCES~

Destructively replaces each element of ~RESULT~ with the result of
applying ~FUNCTION~ to each element of ~RESULT~ and each element of
each sequence in SEQUENCES.

This function is similar in behavior to ~CL:MAP-INTO~ with the
exception that if ~RESULT~ is a vector, then ~FUNCTION~ is only
applied on the elements up-to the fill pointer i.e. the fill-pointer
is not ignored.

***** MAP-INTO

Function: ~MAP-INTO RESULT FUNCTION &REST SEQUENCES~

Applies ~FUNCTION~ on each element of each sequence in ~SEQUENCES~ and
stores the result in RESULT.

***** MAP-TO

Function: ~MAP-TO TYPE FUNCTION &REST SEQUENCES~

Applies ~FUNCTION~ to each element of each sequence in ~SEQUENCES~ and
stores the result in a new sequence of type ~TYPE~ (created using
~SEQUENCE-OF-TYPE~).  Returns the sequence in which the results of
applying function are stored.

This function is equivalent in behavior and arguments to ~CL:MAP~.

***** FOREACH

Function: ~FOREACH &REST SEQUENCES~

Applies ~FUNCTION~ on each element of each sequence in ~SEQUENCES~.

*** Generic Hash-Tables
*** Set Operations
